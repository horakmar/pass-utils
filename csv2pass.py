#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright (C) 2016 Daniele Pizzolli <daniele.pizzolli@create-net.org>
#
# This file is licensed under GPLv2+. Please see COPYING for more
# information.

# Modified by Martin Horak for importing of custom CSV

"""Import password(s) exported by Password Exporter for Firefox in
csv format to pass format.  Supports Password Exporter format 1.1.
"""

import argparse
import base64
import csv
import sys
import subprocess


PASS_PROG = 'pass'
DEFAULT_USERNAME = 'login'


def main():
    "Parse the arguments and run the passimport with appropriate arguments."
    description = """\
    Import password(s) exported by Password Exporter for Firefox in csv
    format to pass format.  Supports Password Exporter format 1.1.

    Check the first line of your exported file.

    Must start with:

    # Generated by Password Exporter; Export format 1.1;

    Support obfuscated export (wrongly called encrypted by Password Exporter).

    It should help you to migrate from the default Firefox password
    store to passff.

    Please note that Password Exporter or passff may have problem with
    fields containing characters like " or :.

    More info at:
    <https://addons.mozilla.org/en-US/firefox/addon/password-exporter>
    <https://addons.mozilla.org/en-US/firefox/addon/passff>
    """
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument(
        "filepath", type=str,
        help="The password Exporter generated file")
    parser.add_argument(
        "-p", "--prefix", type=str,
        help="Prefix for pass store path, you may want to use: sites")
    parser.add_argument(
        "-f", "--force", action="store_true",
        help="Call pass with --force option")
    parser.add_argument(
        "-v", "--verbose", action="store_true",
        help="Show pass output")
    parser.add_argument(
        "-q", "--quiet", action="store_true",
        help="No output")

    args = parser.parse_args()

    passimport(args.filepath, prefix=args.prefix, force=args.force,
               verbose=args.verbose, quiet=args.quiet)


def passimport(filepath, prefix=None, force=False, verbose=False, quiet=False):
    "Import the password from filepath to pass"
    with open(filepath, 'rb') as csvfile:
        obfuscation = False

        reader = csv.DictReader(csvfile, delimiter=',', quotechar='"')
        for row in reader:
#            try:
                username = row['username']
                password = row['password']

                if obfuscation:
                    username = base64.b64decode(row['username'])
                    password = base64.b64decode(row['password'])

                # Not sure if some fiel can be empty, anyway tries to be
                # reasonably safe
                text = '{}\n'.format(password)
                if username:
                    text += 'login: {}\n'.format(username)
                if row['URL']:
                    text += 'URL: {}\n'.format(row['URL'])
                if row['PIN']:
                    text += 'PIN: {}\n'.format(row['PIN'])
                if row['ID']:
                    text += 'ID: {}\n'.format(row['ID'])

                simplename = row['name']

                storepath = simplename

                if prefix:
                    storepath = '{}/{}'.format(prefix, storename)

                cmd = [PASS_PROG, 'insert', '--multiline']

                if force:
                    cmd.append('--force')

                cmd.append(storepath)

                proc = subprocess.Popen(
                    cmd,
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE)
                stdout, stderr = proc.communicate(text)
                retcode = proc.wait()

                # TODO: please note that sometimes pass does not return an
                # error
                #
                # After this command:
                #
                # pass git config --bool --add pass.signcommits true
                #
                # pass import will fail with:
                #
                # gpg: skipped "First Last <user@example.com>":
                #    secret key not available
                # gpg: signing failed: secret key not available
                # error: gpg failed to sign the data
                # fatal: failed to write commit object
                #
                # But the retcode is still 0.
                #
                # Workaround: add the first signing key id explicitly with:
                #
                # SIGKEY=$(gpg2 --list-keys --with-colons user@example.com | \
                #     awk -F : '/:s:$/ {printf "0x%s\n", $5; exit}')
                # pass git config --add user.signingkey "${SIGKEY}"

                if retcode:
                    print 'command {}" failed with exit code {}: {}'.format(
                        " ".join(cmd), retcode, stdout + stderr)

                if not quiet:
                    print 'Imported {}'.format(storepath)

                if verbose:
                    print stdout + stderr

#            except:
#                print 'Error: corrupted line: {}'.format(row)

if __name__ == '__main__':
    main()
